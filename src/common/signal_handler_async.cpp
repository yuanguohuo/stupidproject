#include <unistd.h>
#include <fcntl.h>
#include <assert.h>
#include <poll.h>
#include <string.h>

#include <iostream>
#include <sstream>

#include "common/signal_handler_async.hpp"
#include "common/thread.hpp"
#include "common/mutex.hpp"
#include "common/util.hpp"

namespace stupid {
namespace common {

struct AsyncSignalHandler : public stupid::common::Thread {
  // to kick the thread for
  //   - shutdown
  //   - new handlers
  //   - etc
  int pipefd[2];

  // to signal shutdown
  bool stop = false;

  // for an individual signal
  struct safe_handler {
    safe_handler()
    {
      memset(pipefd,   0, sizeof(pipefd));
      memset(&handler, 0, sizeof(handler));
      memset(&info_t,  0, sizeof(info_t));    
    }

    siginfo_t info_t;
    int pipefd[2];  // write to [1], read from [0]
    signal_handler_t handler;
  };

  // all handlers
  safe_handler* handlers[32] = {nullptr};

  // to protect the handlers array
  mutex lock = make_mutex("AsyncSignalHandler::lock");

  AsyncSignalHandler()
  {
    // create signal pipe
    int r = pipe_cloexec(pipefd, 0);
    //TODO:
    //ceph_assert(r == 0);
    assert(r == 0);

    r = fcntl(pipefd[0], F_SETFL, O_NONBLOCK);

    //TODO:
    //ceph_assert(r == 0);
    assert(r == 0);

    // create thread
    create("signal_handler");
  }

  ~AsyncSignalHandler() override {
    shutdown();
  }

  void signal_thread()
  {
    int r = write(pipefd[1], "\0", 1);
    //TODO:
    //ceph_assert(r == 1);
    assert(r == 1);
  }

  void shutdown()
  {
    stop = true;
    signal_thread();
    join();
  }

  // thread entry point
  void* entry() override
  {
    while (!stop) {
      // build fd list
      struct pollfd fds[33];

      lock.lock();
      int num_fds = 0;
      fds[num_fds].fd = pipefd[0];
      fds[num_fds].events = POLLIN | POLLERR;
      fds[num_fds].revents = 0;
      ++num_fds;
      for (unsigned i=0; i<32; i++) {
        if (handlers[i]) {
          fds[num_fds].fd = handlers[i]->pipefd[0];
          fds[num_fds].events = POLLIN | POLLERR;
          fds[num_fds].revents = 0;
          ++num_fds;
        }
      }
      lock.unlock();

      // wait for data on any of those pipes
      int r = poll(fds, num_fds, -1);
      if (stop) {
        break;
      }

      if (r > 0) {
        char v;

        // consume byte from signal socket, if any.
        TEMP_FAILURE_RETRY(read(pipefd[0], &v, 1));

        lock.lock();
        for (unsigned signum=0; signum<32; signum++) {
          if (handlers[signum]) {
            r = read(handlers[signum]->pipefd[0], &v, 1);
            if (r == 1) {
              siginfo_t * siginfo = &handlers[signum]->info_t;
              std::ostringstream message;
              message << "received signal: " << sig_str(signum);
              switch (siginfo->si_code) {
                case SI_USER:
                  message << " from " << get_process_name_by_pid(siginfo->si_pid);
                  // If PID is undefined, it doesn't have a meaning to be displayed
                  if (siginfo->si_pid) {
                    message << " (PID: " << siginfo->si_pid << ")";
                  } else {
                    message << " (Could be generated by pthread_kill(), raise(), abort(), alarm())";
                  }
                  message << " UID: " << siginfo->si_uid;
                  break;
                default:
                  /* As we have a not expected signal, let's report the structure to help debugging */
                  message << ", si_code: " << siginfo->si_code;
                  message << ", si_value (int): " << siginfo->si_value.sival_int;
                  message << ", si_value (ptr): " << siginfo->si_value.sival_ptr;
                  message << ", si_errno: " << siginfo->si_errno;
                  message << ", si_pid: " << siginfo->si_pid;
                  message << ", si_uid: " << siginfo->si_uid;
                  message << ", si_addr: " << siginfo->si_addr;
                  message << ", si_status: " << siginfo->si_status;
                  break;
              }
              std::cerr << message.str() << std::endl;
              handlers[signum]->handler(signum);
            }
          }
        }
        lock.unlock();
      } 
    }
    return NULL;
  }

  void queue_signal(int signum)
  {
    // If this signal handler is registered, the callback must be
    // defined.  We can do this without the lock because we will never
    // have the signal handler defined without the handlers entry also
    // being filled in.
    // TODO:
    //ceph_assert(handlers[signum]);
    assert(handlers[signum]);
    int r = write(handlers[signum]->pipefd[1], " ", 1);

    //TODO:
    //ceph_assert(r == 1);
    assert(r == 1);
  }

  void queue_signal_info(int signum, siginfo_t *siginfo, void * content) {
    // If this signal handler is registered, the callback must be
    // defined.  We can do this without the lock because we will never
    // have the signal handler defined without the handlers entry also
    // being filled in.
    // TODO:
    //ceph_assert(handlers[signum]);
    assert(handlers[signum]);
    memcpy(&handlers[signum]->info_t, siginfo, sizeof(siginfo_t));
    int r = write(handlers[signum]->pipefd[1], " ", 1);
    //TODO:
    //ceph_assert(r == 1);
    assert(r == 1);
  }

  void register_handler(int signum, signal_handler_t handler, bool oneshot);
  void unregister_handler(int signum, signal_handler_t handler);
};

static AsyncSignalHandler *g_signal_handler = NULL;

static void handler_signal_hook(int signum, siginfo_t * siginfo, void * content) {
  std::cerr << "thread: " << gettid_wrapper() << " got signal " << signum << " --> sending to async signal_handler thread" << std::endl;
  g_signal_handler->queue_signal_info(signum, siginfo, content);
}

void AsyncSignalHandler::register_handler(int signum, signal_handler_t handler, bool oneshot)
{
  int r;

  //TODO:
  //ceph_assert(signum >= 0 && signum < 32);
  assert(signum >= 0 && signum < 32);

  safe_handler *h = new safe_handler;

  r = pipe_cloexec(h->pipefd, 0);
  //TODO:
  //ceph_assert(r == 0);
  assert(r == 0);
  r = fcntl(h->pipefd[0], F_SETFL, O_NONBLOCK);
  //TODO:
  //ceph_assert(r == 0);
  assert(r == 0);

  h->handler = handler;
  lock.lock();
  handlers[signum] = h;
  lock.unlock();

  // signal thread so that it sees our new handler
  signal_thread();
  
  // install our handler
  struct sigaction oldact;
  struct sigaction act;
  memset(&act, 0, sizeof(act));

  act.sa_handler = (signal_handler_t)handler_signal_hook;
  sigfillset(&act.sa_mask);  // mask all signals in the handler
  act.sa_flags = SA_SIGINFO | (oneshot ? SA_RESETHAND : 0);
  int ret = sigaction(signum, &act, &oldact);
  //TODO:
  //ceph_assert(ret == 0);
  assert(ret == 0);
}

void AsyncSignalHandler::unregister_handler(int signum, signal_handler_t handler)
{
  //TODO:
  //ceph_assert(signum >= 0 && signum < 32);
  assert(signum >= 0 && signum < 32);
  safe_handler *h = handlers[signum];
  //TODO:
  //ceph_assert(h);
  //ceph_assert(h->handler == handler);
  assert(h);
  assert(h->handler == handler);

  // restore to default
  signal(signum, SIG_DFL);

  // _then_ remove our handlers entry
  lock.lock();
  handlers[signum] = NULL;
  lock.unlock();

  // this will wake up select() so that worker thread sees our handler is gone
  close(h->pipefd[0]);
  close(h->pipefd[1]);
  delete h;
}

void start_async_signal_handler()
{
  //TODO:
  //ceph_assert(!g_signal_handler);
  assert(!g_signal_handler);
  g_signal_handler = new AsyncSignalHandler;
}

void shutdown_async_signal_handler()
{
  //TODO:
  //ceph_assert(g_signal_handler);
  assert(g_signal_handler);
  delete g_signal_handler;
  g_signal_handler = NULL;
}

void queue_async_signal(int signum)
{
  //TODO:
  //ceph_assert(g_signal_handler);
  assert(g_signal_handler);
  g_signal_handler->queue_signal(signum);
}

void register_async_signal_handler(int signum, signal_handler_t handler)
{
  //TODO:
  //ceph_assert(g_signal_handler);
  assert(g_signal_handler);
  g_signal_handler->register_handler(signum, handler, false);
}

void register_async_signal_handler_oneshot(int signum, signal_handler_t handler)
{
  //TODO:
  //ceph_assert(g_signal_handler);
  assert(g_signal_handler);
  g_signal_handler->register_handler(signum, handler, true);
}

void unregister_async_signal_handler(int signum, signal_handler_t handler)
{
  //TODO:
  //ceph_assert(g_signal_handler);
  assert(g_signal_handler);
  g_signal_handler->unregister_handler(signum, handler);
}

} //namespace common
} //namespace stupid
